{"version":3,"sources":["formatURL.ts","urlTestRegex.ts","parseURL.ts","index.ts"],"names":[],"mappings":"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","file":"index.map","sourceRoot":"../src","sourcesContent":["/**\n * Format an URL string form url object\n *\n * @param urlObject\n */\nconst format = (urlObject: URL.IURLParsed) => {\n  /**\n   * Fix the protocol\n   * => mailto, sftp and others don't have a //\n   */\n  let protocol = (urlObject.protocol || '').replace(/:/g, '');\n  if (\n    protocol === 'http' ||\n    protocol === 'https' ||\n    protocol === 'ftp' ||\n    protocol === 'file'\n  ) {\n    protocol = protocol + '://';\n  } else if (protocol !== '') {\n    protocol = protocol + ':';\n  }\n\n  /**\n   * Build the auth\n   */\n  let auth = '';\n  if (urlObject.auth && urlObject.auth.password && urlObject.auth.username) {\n    auth = `${urlObject.auth.username}:${urlObject.auth.password}@`;\n  }\n\n  /**\n   * Build the host\n   */\n  let host: string | null = urlObject.host || null;\n  if (!host || host === '') {\n    host = urlObject.hostname || null;\n    if (!host) throw new TypeError('At leas a host must be provided.');\n    if (urlObject.port) host = `${host}:${urlObject.port}`;\n  }\n\n  /**\n   * Build the pathname\n   */\n  let pathname = urlObject.pathname || '';\n  if (pathname.substr(0, 1) !== '/') pathname = `/${pathname}`;\n\n  /**\n   * Build the search\n   */\n  let search = urlObject.search || '';\n  if (!search && urlObject.query) {\n    search = `?${urlObject.query}`;\n  }\n\n  /**\n   * Build the hash\n   */\n  let hash = urlObject.hash || '';\n  if (hash !== '' && hash.substr(0, 1) !== '#') hash = `#${hash}`;\n\n  const url = protocol + auth + host + pathname + search + hash;\n\n  return url;\n};\n\nexport default format;\n","// Regular Expression for URL validation\n//\n// Author: Diego Perini\n// Created: 2010/12/05\n// Updated: 2018/09/12\n// License: MIT\n//\n// Copyright (c) 2010-2018 Diego Perini (http://www.iport.it)\n//\n// Permission is hereby granted, free of charge, to any person\n// obtaining a copy of this software and associated documentation\n// files (the \"Software\"), to deal in the Software without\n// restriction, including without limitation the rights to use,\n// copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the\n// Software is furnished to do so, subject to the following\n// conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n// OTHER DEALINGS IN THE SOFTWARE.\n//\n// the regular expression composed & commented\n// could be easily tweaked for RFC compliance,\n// it was expressly modified to fit & satisfy\n// these test for an URL shortener:\n//\n//   http://mathiasbynens.be/demo/url-regex\n//\n// Notes on possible differences from a standard/generic validation:\n//\n// - utf-8 char class take in consideration the full Unicode range\n// - TLDs have been made mandatory so single names like \"localhost\" fails\n// - protocols have been restricted to ftp, http and https only as requested\n//\n// Changes:\n//\n// - IP address dotted notation validation, range: 1.0.0.0 - 223.255.255.255\n//   first and last IP address of each class is considered invalid\n//   (since they are broadcast/network addresses)\n//\n// - Added exclusion of private, reserved and/or local networks ranges\n// - Made starting path slash optional (http://example.com?foo=bar)\n// - Allow a dot (.) at the end of hostnames (http://example.com.)\n// - Allow an underscore (_) character in host/domain names\n// - Check dot delimited parts length and total length\n// - Made protocol optional, allowed short syntax //\n//\n// Compressed one-line versions:\n//\n// Javascript regex version\n//\n// /^(?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u00a1-\\uffff][a-z0-9\\u00a1-\\uffff_-]{0,62})?[a-z0-9\\u00a1-\\uffff]\\.)+(?:[a-z\\u00a1-\\uffff]{2,}\\.?))(?::\\d{2,5})?(?:[/?#]\\S*)?$/i\n//\n// PHP version (uses % symbol as delimiter)\n//\n// %^(?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\x{00a1}-\\x{ffff}][a-z0-9\\x{00a1}-\\x{ffff}_-]{0,62})?[a-z0-9\\x{00a1}-\\x{ffff}]\\.)+(?:[a-z\\x{00a1}-\\x{ffff}]{2,})\\.?))(?::\\d{2,5})?(?:[/?#]\\S*)?$%iuS\n//\nexport default new RegExp(\n  '^' +\n    // protocol identifier (optional)\n    // short syntax // still required\n    '(?:(?:(?:https?|ftp):)?\\\\/\\\\/)' +\n    // user:pass BasicAuth (optional)\n    '(?:\\\\S+(?::\\\\S*)?@)?' +\n    '(?:' +\n    // IP address exclusion\n    // private & local networks\n    '(?!(?:10|127)(?:\\\\.\\\\d{1,3}){3})' +\n    '(?!(?:169\\\\.254|192\\\\.168)(?:\\\\.\\\\d{1,3}){2})' +\n    '(?!172\\\\.(?:1[6-9]|2\\\\d|3[0-1])(?:\\\\.\\\\d{1,3}){2})' +\n    // IP address dotted notation octets\n    // excludes loopback network 0.0.0.0\n    // excludes reserved space >= 224.0.0.0\n    // excludes network & broacast addresses\n    // (first & last IP address of each class)\n    '(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])' +\n    '(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}' +\n    '(?:\\\\.(?:[1-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))' +\n    '|' +\n    // host & domain names, may end with dot\n    // can be replaced by a shortest alternative\n    // (?![-_])(?:[-\\\\w\\\\u00a1-\\\\uffff]{0,63}[^-_]\\\\.)+\n    '(?:' +\n    '(?:' +\n    '[a-z0-9\\\\u00a1-\\\\uffff]' +\n    '[a-z0-9\\\\u00a1-\\\\uffff_-]{0,62}' +\n    ')?' +\n    '[a-z0-9\\\\u00a1-\\\\uffff]\\\\.' +\n    ')+' +\n    // TLD identifier name, may end with dot\n    '(?:[a-z\\\\u00a1-\\\\uffff]{2,}\\\\.?)' +\n    ')' +\n    // port number (optional)\n    '(?::\\\\d{2,5})?' +\n    // resource path (optional)\n    '(?:[/?#]\\\\S*)?' +\n    '$',\n  'i',\n);\n","import urlTestRegex from './urlTestRegex';\n\n/**\n * Parse an url to give an object\n *\n * @param url\n */\nconst parse = (url: string): URL.IURLParsed | boolean => {\n  /**\n   * Manual check\n   */\n  if (!url || typeof url !== 'string') {\n    return false;\n  }\n\n  /**\n   * Test if we have a valid url\n   */\n  const isValidURL = urlTestRegex.test(url);\n\n  /**\n   * Init the variables\n   */\n  let baseURL: string | Array<string> = decodeURIComponent(url);\n  let auth: { [key: string]: string } = {};\n  let domain: string | null = null;\n  let domainChain: Array<string> | null = null;\n  let hash: string | null = null;\n  let host: string | null = null;\n  let hostname: string | null = null;\n  let href = url;\n  let origin: string | null = null;\n  let path: string | null = null;\n  let pathname: string | null = null;\n  let port: string | null = null;\n  let protocol: string | null = null;\n  let query: string | null = null;\n  let queryParams: { [key: string]: string | Array<string> } = {};\n  let search: string | null = null;\n  let tld: string | null = null;\n\n  /**\n   * Build the protocol\n   */\n  baseURL = baseURL.split('//');\n  if (baseURL.length > 1) {\n    protocol = baseURL[0] || null;\n    baseURL = baseURL[1];\n  } else {\n    baseURL = baseURL[0];\n  }\n\n  /**\n   * Build the auth\n   */\n  baseURL = baseURL.split('@');\n  if (baseURL.length > 1) {\n    const authData = baseURL[0].split(':');\n    auth = {\n      password: authData[1] || '',\n      username: authData[0] || '',\n    };\n    baseURL = baseURL[1];\n  } else {\n    baseURL = baseURL[0];\n  }\n\n  /**\n   * Build the hash\n   */\n  baseURL = baseURL.split('#');\n  if (baseURL.length > 1) {\n    hash = `${baseURL[1]}`;\n  }\n  baseURL = baseURL[0];\n\n  /**\n   * Build the search\n   */\n  baseURL = baseURL.split('?');\n  if (baseURL.length > 2) {\n    console.error('Malformed URL: multiple searches.');\n  } else if (baseURL.length === 2) {\n    search = `?${baseURL[1]}`;\n    query = baseURL[1];\n    query.split('&').forEach(query => {\n      const queryData = query.split('=');\n      const key = String(queryData[0]);\n      const value = String(queryData[1]);\n      if (!queryParams[key]) {\n        queryParams[key] = value;\n      } else if (typeof queryParams[key] === 'string') {\n        queryParams[key] = [queryParams[key] as string, value];\n      } else {\n        queryParams[key] = [...(queryParams[key] as Array<string>), value];\n      }\n    });\n  }\n  baseURL = baseURL[0];\n\n  /**\n   * Build the path\n   */\n  baseURL = baseURL.split('/');\n  if (baseURL.length === 1) {\n    pathname = '/';\n  } else {\n    pathname = '/' + baseURL.slice(1).join('/');\n  }\n  path = (pathname || '') + (search || '');\n  baseURL = baseURL[0] || '';\n\n  /**\n   * Build the host, domain\n   */\n  baseURL = baseURL.split('/');\n  host = baseURL[0] || '';\n  const hostData = host.split(':');\n  if (hostData.length === 2) {\n    port = hostData[1] || null;\n  }\n  hostname = hostData[0];\n  domainChain = hostData[0].split('.').reverse();\n  tld = domainChain[0] || null;\n  domain = domainChain[1] || null;\n  baseURL = baseURL[1];\n\n  /**\n   * Build the origin\n   */\n  origin = host || '';\n  if (protocol) {\n    if (\n      protocol === 'http:' ||\n      protocol === 'https:' ||\n      protocol === 'ftp:' ||\n      protocol === 'file:'\n    ) {\n      origin = protocol + '//' + host;\n    } else {\n      protocol = protocol + host;\n    }\n  }\n\n  return {\n    auth,\n    domain,\n    domainChain,\n    hash,\n    host,\n    hostname,\n    href,\n    isValidURL,\n    origin,\n    path,\n    pathname,\n    port,\n    protocol,\n    query,\n    queryParams,\n    search,\n    tld,\n  };\n};\n\nexport default parse;\n","import format from './formatURL';\nimport parse from './parseURL';\n\nconst url: URL.IURL = {\n  format,\n  parse,\n};\n\nexport default url;\n"]}